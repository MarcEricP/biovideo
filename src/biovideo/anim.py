from __future__ import annotations
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import matplotlib.font_manager as fm
import matplotlib.colors as mcolors
from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
from PIL import Image as PILImage
from PIL import ImageDraw, ImageFont
from typing import Optional, Union

from .ffmpeg_utils import get_ffmpeg_path
from .colors import rand_cmap

ColormapLike = Union[str, mcolors.Colormap]


def _prepare_ffmpeg():
    ffmpeg_path = get_ffmpeg_path()
    plt.rcParams["animation.ffmpeg_path"] = ffmpeg_path


def _pil_font(fontsize: int, font_path: str | None = None):
    if font_path:
        try:
            return ImageFont.truetype(font_path, fontsize)
        except Exception:
            pass
    try:
        prop = fm.FontProperties(size=fontsize)
        fp = fm.findfont(prop)
        return ImageFont.truetype(fp, fontsize)
    except Exception:
        return ImageFont.load_default()


def _resolve_cmap(spec: Optional[ColormapLike], fallback: ColormapLike) -> mcolors.Colormap:
    """Return a matplotlib Colormap from a string or Colormap; use fallback if None."""
    if spec is None:
        spec = fallback
    if isinstance(spec, mcolors.Colormap):
        return spec
    # assume string name
    return plt.get_cmap(str(spec))


def make_movie(
    movie: np.ndarray,
    save_path: str,
    mask: np.ndarray | None = None,
    label_mask: bool = False,
    num_unit_scale: float = 1,
    scale: float = 16,
    space_unit: str = "μm",
    scale_width: float = 10,
    time_interval: float = 5,
    time_unit: str = "sec",
    pos_time = (0.1,0.1),
    fps: int = 10,
    img_cmap: ColormapLike = "gray",
    mask_cmap: Optional[ColormapLike] = None,
    h_figsize: float = 5,
    fontsize: int = 15,
    first_label_red: bool = False,
    label_font_path: str | None = None,
) -> None:
    """
    Create an MP4 movie from a 3D array (T,H,W). Optionally overlay a label mask.

    Parameters
    ----------
    movie : (T, H, W)
        Image sequence.
    save_path : str
        Output path (e.g. "out.mp4").
    mask : (T, H, W) int, optional
        Integer labels (0 = background). If label_mask=True, labels are drawn on top of a colored RGBA mask.
    label_mask : bool
        If True, draw numeric labels at component centroids.
    num_unit_scale : float
        Physical units displayed on the scale bar text.
    scale : float
        Number of pixels corresponding to num_unit_scale units.
    space_unit : str
        Text unit for the scale bar (default: µm).
    pos_time : where to put the timestamp (expressed in proportion of height and width)
    img_cmap : str or matplotlib.colors.Colormap
        **Colormap for the movie frames**. Accepts a Matplotlib colormap name (e.g. "gray", "magma")
        or a Colormap instance (e.g. matplotlib.cm.viridis).
    mask_cmap : str or matplotlib.colors.Colormap, optional
        **Colormap for the mask** when label_mask=False or for color picks when label_mask=True.
        If None, a bright random ListedColormap is generated with background index 0 black.
    h_figsize : float
        Figure height in inches.
    fontsize : int
        Base font size for scalebar and timestamp.
    first_label_red : bool
        If True, force label 1 to be red in the autogenerated palette.
    label_font_path : str, optional
        Path to a .ttf font for label drawing; falls back to Matplotlib's default font.

    Notes
    -----
    **Defining a colormap**
    - String name: img_cmap="magma"
    - Prebuilt object: from matplotlib import cm; img_cmap=cm.magma
    - Custom categorical: from matplotlib.colors import ListedColormap; mask_cmap=ListedColormap([[0,0,0,0],[1,0,0,1],[0,1,0,1]])
    """
    _prepare_ffmpeg()

    T, H, W = movie.shape
    aspect_ratio = H / W
    plt.rcParams["figure.figsize"] = (h_figsize / aspect_ratio, h_figsize)

    fig, ax = plt.subplots()
    fig.subplots_adjust(left=0, bottom=0, right=1, top=1)
    ax.axis("off")

    img_cmap_resolved = _resolve_cmap(img_cmap, "gray")
    img = ax.imshow(movie[0], cmap=img_cmap_resolved)

    fontprops = fm.FontProperties(size=fontsize)
    scalebar = AnchoredSizeBar(
        ax.transData,
        scale * num_unit_scale,
        f"{num_unit_scale} {space_unit}",
        "lower right",
        pad=0.1,
        color="white",
        frameon=False,
        size_vertical=scale_width,
        fontproperties=fontprops,
    )
    ax.add_artist(scalebar)

    rgba_mask = None
    if mask is not None:
        default_mask_cmap = rand_cmap(mask.max() + 1, type='bright', first_color_black=True, last_color_black=False, second_color_red=first_label_red)
        mask_cmap_resolved = _resolve_cmap(mask_cmap, default_mask_cmap)


        rgba_mask = np.zeros(mask.shape + (4,), dtype=float)
        pil_font = _pil_font(fontsize, label_font_path)
        for t in range(mask.shape[0]):
            rgba = mask_cmap_resolved(mask[t])
            final_img = (255 * rgba).astype(np.uint8)
            pil_final = PILImage.fromarray(final_img)
            if label_mask:
                draw = ImageDraw.Draw(pil_final)
                values = np.unique(mask[t])
                values = values[values != 0]
                for val in values:
                    rr, cc = np.nonzero(mask[t] == val)
                    if rr.size == 0:
                        continue
                    centroid = (int(np.round(cc.mean()) - 30), int(np.round(rr.mean()) - 30))
                    color = tuple(int(255 * c) for c in mask_cmap_resolved(val)[:3])
                    draw.text(centroid, f"{val - 1}", fill=color, font=pil_font)
            rgba_mask[t] = np.array(pil_final) / 255.0
        img_mask = ax.imshow(rgba_mask[0])

    time_text = ax.text(int(pos_time[0] * H), int(pos_time[1] * W * aspect_ratio), '', fontsize=fontsize, color='white')

    def update_frame(frame: int):
        img.set_data(movie[frame])
        if mask is not None:
            img_mask.set_data(rgba_mask[frame])
        tval = time_interval * frame
        if float(tval).is_integer():
            time_text.set_text(f"{int(tval)} {time_unit}")
        else:
            time_text.set_text(f"{tval:0.2f} {time_unit}")

    ani = animation.FuncAnimation(fig=fig, func=update_frame, frames=T, interval=int(1000 / fps))
    ani.save(filename=save_path, writer='ffmpeg')
    plt.close(fig)


def make_movie_and_plot(
    movie: np.ndarray,
    save_path: str,
    time: np.ndarray,
    metric: np.ndarray,
    xlabel: str = "",
    ylabel: str = "",
    mask: np.ndarray | None = None,
    label_mask = False,
    num_unit_scale: float = 1,
    scale: float = 16,
    space_unit: str = "μm",
    constant_amplitude: float | None = None,
    y_not_under_zero: bool = True,
    scale_width: float = 10,
    time_interval: float = 5,
    time_unit: str = "sec",
    pos_time = (0.1,0.1),
    fps: int = 10,
    img_cmap: ColormapLike = "gray",
    mask_cmap: Optional[ColormapLike] = None,
    h_figsize: float = 20,
    fontsize: int = 15,
    first_label_red: bool = False,
    label_font_path: str | None = None,
) -> None:
    """Same as make_movie, with an extra metric trace plotted alongside.

    Colormap handling is identical; see make_movie docstring for examples.
    """
    _prepare_ffmpeg()

    T, H, W = movie.shape
    aspect_ratio = H / W

    plt.rcParams["figure.figsize"] = (h_figsize, h_figsize * 3 / 8)
    plt.rcParams.update({'font.size': 20})

    fig, ax = plt.subplots(1, 2)
    fig.subplots_adjust(left=0.01, bottom=0.1, right=0.99, top=0.99)

    ax[0].axis("off")

    img_cmap_resolved = _resolve_cmap(img_cmap, "gray")
    img = ax[0].imshow(movie[0], cmap=img_cmap_resolved)

    fontprops = fm.FontProperties(size=fontsize)
    scalebar = AnchoredSizeBar(
        ax[0].transData,
        scale * num_unit_scale,
        f"{num_unit_scale} {space_unit}",
        "lower right",
        pad=0.1,
        color='white',
        frameon=False,
        size_vertical=scale_width,
        fontproperties=fontprops,
    )
    ax[0].add_artist(scalebar)

    rgba_mask = None
    if mask is not None:
        default_mask_cmap = rand_cmap(mask.max() + 1, type='bright', first_color_black=True, last_color_black=False, second_color_red=first_label_red)
        mask_cmap_resolved = _resolve_cmap(mask_cmap, default_mask_cmap)


        rgba_mask = np.zeros(mask.shape + (4,), dtype=float)
        pil_font = _pil_font(fontsize, label_font_path)
        for t in range(mask.shape[0]):
            rgba = mask_cmap_resolved(mask[t])
            final_img = (255 * rgba).astype(np.uint8)
            pil_final = PILImage.fromarray(final_img)
            if label_mask:
                draw = ImageDraw.Draw(pil_final)
                values = np.unique(mask[t])
                values = values[values != 0]
                for val in values:
                    rr, cc = np.nonzero(mask[t] == val)
                    if rr.size == 0:
                        continue
                    centroid = (int(np.round(cc.mean()) - 30), int(np.round(rr.mean()) - 30))
                    color = tuple(int(255 * c) for c in mask_cmap_resolved(val)[:3])
                    draw.text(centroid, f"{val - 1}", fill=color, font=pil_font)
            rgba_mask[t] = np.array(pil_final) / 255.0
        img_mask = ax[0].imshow(rgba_mask[0])

    time_text = ax[0].text(int(pos_time[0] * H), int(pos_time[1] * W * aspect_ratio), '', fontsize=fontsize, color='white')

    ax[1].plot(time, metric, zorder=0)
    ax[1].set_xlabel(xlabel)
    ax[1].set_ylabel(ylabel)
    scat = ax[1].scatter(time[0], metric[0], zorder=2, s=200)

    if constant_amplitude is not None:
        amp = float(metric.max() - metric.min())
        ymin = float(metric.min() - (constant_amplitude - amp) / 2)
        ymax = float(metric.max() + (constant_amplitude - amp) / 2)
        if ymin < 0 and y_not_under_zero:
            diff = 0 - ymin
            ymin += diff
            ymax += diff
        ax[1].set_ylim([ymin, ymax])

    def update_frame(frame: int):
        img.set_data(movie[frame])
        if mask is not None:
            img_mask.set_data(rgba_mask[frame])
        tval = time_interval * frame
        if float(tval).is_integer():
            time_text.set_text(f"{int(tval)} {time_unit}")
        else:
            time_text.set_text(f"{tval:0.2f} {time_unit}")
        try:
            scat.set_offsets(np.array([[time[frame], metric[frame]]]))
        except Exception:
            pass

    ani = animation.FuncAnimation(fig=fig, func=update_frame, frames=T, interval=int(1000 / fps))
    ani.save(filename=save_path, writer='ffmpeg')
    plt.close(fig)
